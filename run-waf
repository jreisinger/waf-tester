#!/bin/bash

set -e # exit if command returns non-zero exit code

######## FUNCTION ########

# Print colorful messages.
print_msg() {
    local msg=$1
    local msg_type=$2

    local color
    local nocolor='\033[0m'

    # https://stackoverflow.com/questions/5947742/how-to-change-the-output-color-of-echo-in-linux
    case $msg_type in
        err)
            color='\033[0;31m'
            ;;
        ok)
            color='\033[0;32m'
            ;;
        *)
            color='\033[0;34m'
            ;;
    esac

    printf "${color}${msg}${nocolor}\n"
}

# Create temporary directory and store its name into global variable TMPDIR.
create_temp_dir() {
    print_msg "Create temporary directory"
    TMPDIR=$(mktemp -d)

    # Bail out if the temp directory wasn't created successfully.
    if [ ! -e $TMPDIR ]; then
        >&2 echo "Failed to create temp directory"
        exit 1
    fi
}

create_logs_dir() {
    print_msg "Create directories for logs in /tmp/var/log"
    mkdir -p /tmp/var/log
    mkdir -p /tmp/var/log/nginx
}

# Setup temp dir, copy needed files into it and create dirs for logs.
copy_image_files() {
    local dir=$1

    print_msg "Copy all needed files to $TMPDIR"
    cp -r $dir/* $TMPDIR
}

create_docker_compose_file() {
    print_msg "Create $TMPDIR/docker-compose.yaml"
    cat << EOF > "$TMPDIR/docker-compose.yaml"
version: '3.3'

services:
    testing-webserver:
        container_name: testing-webserver
        image: nginx
        ports:
            - 8080:80

    testing-waf:
        container_name: testing-waf
        depends_on:
            - testing-webserver
        build:
            dockerfile: Dockerfile
            context: .
        ports:
            - 80:80
        volumes:
            - type: bind
              source: /tmp/var/log
              target: /var/log
EOF
}

# Remove docker containers and networks. Remove temp dir.
clean_up () {
    print_msg "Clean up"
    docker-compose down
    #rm -rf /tmp/var/log
    rm -rf "$TMPDIR"
}

# Build and run WAF and protected demo app.
build_waf() {
    local verbose=$1

    print_msg "Run docker images for WAF and protected web server"
    cd $TMPDIR
    if [[ $verbose == 1 ]]; then
        docker-compose up -d --build
    else
        docker-compose up -d --build > /dev/null
    fi
}

# Test WAF has been started.
test_waf_is_up() {
    print_msg "Check WAF is up and proxying requests"
    sleep 3
    if curl -sI localhost:80 | grep -E "^HTTP.*OK" > /dev/null; then
        docker ps
        print_msg "WAF container is up and running" "ok"
    else
        docker logs testing-waf
        print_msg "WAF container is not working" "err"
    fi
}

help_and_exit() {
    cat << EOF
${0##*/} [options] DIR

Build a WAF container and run it locally together with a test web server
container. DIR is directory containing the Dockerfile and possibly other
related files.

  options:
    -h, -?  help
    -v      be verbose
    -s      sleep (don't clean up containers) until Ctrl-C
EOF

    exit $1
}

######## MAIN ########

# A POSIX variable
OPTIND=1    # Reset in case getopts has been used previously in the shell.

# Initialize our own variables:
verbose=0
mysleep=0

# getops can't handle long options (--help) but can handle options clustering
# (-vf FILE)
while getopts "h?vs" opt; do
    case "$opt" in
    h|\?)
        help_and_exit 0
        ;;
    v)  verbose=1
        ;;
    s)  mysleep=1
        ;;
    esac
done

# Shift off the options and optional --
shift $((OPTIND-1))
[ "$1" = "--" ] && shift

dir="$@"
if [[ ! -d $dir ]]; then
    echo "'$dir' is not a valid directory"
    echo
    help_and_exit
fi

# Make sure we run cleanup actions even if the script exits abnormally.
trap "exit 1"   HUP INT PIPE QUIT TERM
trap clean_up   EXIT

create_temp_dir
create_logs_dir
create_docker_compose_file
copy_image_files "$dir"
build_waf "$verbose"
test_waf_is_up

if [[ $mysleep == 1 ]]; then
    print_msg "Sleeping until Ctrl-C"
    sleep 999999
fi
